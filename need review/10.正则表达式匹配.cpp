/*
'.'可以匹配一个单字符；'*'可以匹配前面字符任意次
不考虑'*',我们能做的就是一个一个匹配
while(i<s.size() && j<p.size())
{
    // '.'是万金油
    if(s[i] == p[j] || p[j] == '.')
    // 匹配
    i++;j++;
    else
    //不匹配
    return false;
}

那么再加入'*'，需要根据前一个字符做判断，那么定p[j+1]='*'时，分情况讨论
1 如果s[i]==p[j]，有两种情况
    1) p[j]有可能匹配多个字符，比如s='aaa', p='a*'
    2) p[j]有可能只能匹配0个字符，比如s='aa', p='a*aa",因为后面的字符可以匹配s

2 如果s[i]!=p[j]，那就只有一种情况
    p[j]只能匹配0次，然后看下一个字符能否匹配s[i]，比如s='aa', p='b*aa"

代码：
if(s[i] == p[j] || p[j] == '.')
{
    //匹配
    if(j<p.size()-1 && p[j+1] == '*')
    {
        // 有*通配符，可以匹配0次或多次
    }
    else 
    {
        // 无*通配符，老老实实匹配1次
        i++; j++;
    }
else //s[i] != p[j]
    {
        // 不匹配
        if(j<p.size()-1 && p[j+1] == '*')
        {
            // 只能匹配0次，看后面
        }
        else
        {
            // 没有'*'，匹配不下去了
            return false;
        }
    }
}

*/